//            node Lesson_5/this        - запуск через термінал ≡

//* коли порівнюєте об'єкти або функції за допомогою ===, ви порівнюєте посилання на об'єкти, а не їхні зовнішній вигляд або структуру:
// console.log("[] === []: ", [] === []);  //  [] === []:  false
// console.log("{} === {}: ", {} === {});   //   {} === {}:  false
// console.log(
//   "function() {} === function() {}: ",      //   function() {} === function() {}:  false
//   function () {} === function () {}
// );

/*
 * Контекст (this)
 *    - Где и как была объявлена функция НЕ ИМЕЕТ НИКАКОГО ВЛИЯНИЯ на контекст.
 *    - Контекст определяется В МОМЕНТ ВЫЗОВА ФУНКЦИИ, если он не привязан явно.
 */

/*
 * Как метод объекта. В контексте объекта.
 */

// const user = {
//   tag: "Mango",
//   showTag() {
//     console.log("showTag -> this", this);
//   },
// };

// user.showTag();
//?=================================================================================================================================
//* ключове слово 'this' визначає контекст виконання ф-ції і вказує на об'єкт, до якого належить ф-ція.
//* Різниця між '=> ф-ями' і звичайними - в тому, як вони обробляють значення 'this'.

//! Значення 'this' у звичайних ф-ціях:
//* У звичайній ф-ції, значення 'this' залежить від контексту виклику ф-ції. Воно може змінюватись залежно від того, як саме було викликано ф-цію. Наприклад:

// Звичайна функція
// function greet() {
//   console.log('Привіт, ' + this.name);
// }

// const person = {
//   name: 'Василь',
//   greet: greet
// };

// const cat = {
//   name: 'Мурка',
//   greet: greet
// };

// person.greet(); // Виводить: Привіт, Василь
// cat.greet(); // Виводить: Привіт, Мурка

//* В цьому прикладі, 'this' визначається об'єктом, на якому була викликана ф-ція greet(). У першому випадку 'this' вказує на об'єкт person, а у другому випадку на об'єкт cat.

//! Значення this у стрілкових функціях:
//* У => ф-ціях, значення 'this' використовується зовнішньої ф-ції і залишається незмінним всередині стрілкової функції. Воно не залежить від контексту виклику ф-ції. Наприклад:

// Стрілкова функція
// const greet = () => {
//     name: 'Petro',
//   console.log('Привіт, ' + this.name);
// };

// const person = {
//   name: 'Василь',
//   greet: greet
// };

// const cat = {
//   name: 'Мурка',
//   greet: greet
// };

// person.greet(); // Виводить: Привіт, undefined
// cat.greet(); // Виводить: Привіт, undefined

//* В цьому прикладі, this в стрілковій функції greet() не визначається об'єктом, на якому викликана функція.
//* Замість цього, воно використовує значення this зовнішньої функції, в даному випадку, глобального контексту, де this не має визначеного значення, тому результатом є undefined.

//* Важливо відмітити, що стрілкові функції не мають власного this і не можуть бути викликані за допомогою new оператора як конструктори.
//*  Вони зручно використовуються в контекстах, де потрібно зберігати значення this зовнішньої функції.

// const person = {
//   name: 'Василь',
//   greet: function() {
//     const arrowGreet = () => {
//       console.log('Привіт, ' + this.name); //   аналогічно -  person.name
//     };
//     arrowGreet();
//   }
// };

// person.greet(); // Виведе: Привіт, Василь

//* Це основна різниця між стрілковими функціями та звичайними функціями щодо визначення значення this.

// !===========================================================================================
//?            Set

//* Коли створюється новий об'єкт Set з масиву emails, всі дублікати видаляються автоматично.
//* Set - це тип даних у JS, який зберігає унікальні значення. Він зберігає лише унікальні елементи і відкидає будь - які дублікати.

//* При створенні об'єкта Set з масиву emails, внутрішній алгоритм Set проходить через всі елементи масиву та додає їх до себе,
//*  але зберігає лише унікальні значення.Якщо в масиві були дублікати email - адрес, то після створення об'єкта Set вони будуть автоматично видалені,
//*  залишивши лише унікальні значення.
// !===========================================================================================
